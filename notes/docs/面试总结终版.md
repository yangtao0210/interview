# 一、MYSQL

## **1.MYSQL的索引**

### 1.1 概述

```mysql
1)索引是存储引擎快速查找记录的一种数据结构，在存储引擎中实现;
2)使用索引的主要目的就是优化查询速度;
3)索引中存储对数据表中所有记录的引用指针,索引以文件的形式存储在磁盘中。
### 优势
# 1.提高语句查询效率，减少IO操作次数；
# 2.索引列会进行排序，使用分组和排序子句查询时，可以显著减少查询时间
### 缺点
# 1.索引文件需要占用物理空间
# 2.创建和维护索引比较耗时
# 3.索引需要动态维护，会降低数据更新效率
```

### 1.2 分类

```MYSQL
1.单列索引：
    普通索引:允许空值 & 重复值
    唯一索引:允许空值 & 不可重复
    主键索引:不允许空值 & 唯一
2.组合索引：在表中的多个字段上创建索引，遵循最左前缀原则；
## MyIsam引擎支持
3.全文索引：MyIsam引擎中使用，只能在 char,varchar,text 字段类型上使用。
4.空间索引：MySQL 在 5.7 之后的版本支持了空间索引
## Memory引擎支持
5.哈希索引：基于哈希表实现【无法用于排序、不支持部分索引匹配、不支持范围查找】
6.覆盖索引：可以避免二级索引的回表查询。【覆盖是指查询的字段都是索引字段】
```

### 1.3 索引内存模型

#### 1.3.1 哈希表

```mysql
以键值对存储数据的结构。
	key 用于存储索引列；
	value 就是某行的数据或者是它的磁盘地址。
## 底层结构：数组 + 链表实现
## 存在问题
# 无法用于排序、不支持部分索引匹配、不支持范围查找
```

#### 1.3.2 有序数组

```mysql
主要解决区间查询慢的问题，适用于存储不经常变动的数据,新增数据的成本太高。
## 底层主要通过二分查找来提高查询效率。
```

#### 1.3.3  B树

```mysql
思想 : 通过减少树的高度，来减少磁盘的访问次数，通过扩展树的分支来降低树的高度，从而提高查询效率。
说明：
	InnoDB 存储引擎一次IO会读取一页(默认16k)数据，二叉树一次IO有效数据量为只有16个字节，空间利用率极低，为最大化利用一次IO空间，考虑在一个节点尽可能多的存储元素。根据页大小 & 一次IO的字节数 （ 16k / 16 = 1000）==>每个节点可以存储1000个索引。这样一来，1百万条数据只需要2层就可存储（只需要2次操作就可以查询到全部数据）
### 存在问题
# 1.叶子节点无指针相连，范围查询时会增加磁盘的IO次数，查询效率低。【范围查找过程为:从根节点开始先查找左边界，再从根节点开始查找右边界】
# 2.如果data存储的是行记录，行所占空间会随着列数的增多而变大，因为页大小固定，此时，一个页中可存储的数据量会变少，树会变高，IO次数会增多，效率变低。
```

#### 1.3.4 B+ 树

```mysql
与B Tree有两点不同：
1）B+ Tree的非叶子节点不存放数据，只存放键值；B Tree叶子 & 非叶子节点都存放数据
2）B+ Tree的叶子节点之间通过双向指针相连，构成双向有序链表。
### 存在疑问：B+ Tree的数据都存在于叶子节点，只有遍历到叶子节点才能查出数据，而B Tree 不需要遍历到叶子节点就可以查询到数据，效率不是变慢了吗？
### 解答：B+ 树非叶子节点只存储键值，键所需存储空间比数据少的多，在页大小固定的情况下，每个节点就可以存储更多的索引，此时，索引树的高度会降低，磁盘IO操作变少，查询效率会有所提高。**
```

### **<font color = yellow> 1.4 MYSQL 索引是如何执行的</font>**

#### 1.4.1 聚簇索引（主键索引、一级索引）

```mysql
使用B+ Tree构建,叶子节点存储数据表的某一行数据。当表没有创建主键索引时,Innodb引擎会自动创建row_id作为数据表的主键索引。
```

**存储结构**

![image-20210722200143366](..\pictures\image-20210722200143366.png)

**索引查找执行流程：<font color = yellow>可以利用叶子节点之间构建的双向有序链表提高效率</font>**

![image-20210722200844600](..\pictures\\image-20210722200844600.png)

#### 1.4.2 非聚簇索引（二级索引、辅助索引、普通索引）

```mysql
使用B+ Tree构建,叶子节点 & 非叶子节点均存储键值，需要进行‘回表’查询。
```

**存储结构**

![image-20210722201304132](..\pictures\image-20210722201304132.png)

**查找流程：<font color = yellow>需要进行回表查询</font>**

![image-20210722201716561](..\pictures\image-20210722201716561.png)

## **2.MYSQL事务**

### 	2.1事务隔离级别

### 	2.2事务实现原理 & MVCC 

## **3.MYSQL锁**

## **4.MYSQL引擎**

## **5.高频面试题**

### 5.1主键自增问题

#### 5.1.1 自增主键为何不用varchar?

```mysql
UUID是 32个字符+4个'-'组成，长度为36,虽然UUID可以保证唯一性，但是有两个致命的缺点：
	1)UUID不是自增的，插入可能会导致页分裂，树高度增加，性能下降。
    MYSQL中索引的数据结构是B+树，这种数据结构的特点是索引树上的节点数据有序，如果使用UUID作为主键，每次插入数据时，因为无法保证每次产生的UUID有序，所以会出现新的UUID插入到索引树的中间去，频繁导致页分裂，使得性能下降。
    2)太占用内存。
    ① 字符串需要从前向后比较，字符串越长，性能就越差；
    ② 字符串比较占用内存，数据页的大小是固定的，主键越长，能存储的数量就越少，最终会导致索引树的高度越大，在索引搜索时发生磁盘IO的次数就越多，导致性能下降。
```

#### 5.5.2 自增ID用完了怎么处理？

**<font color = yellow>分两种情况讨论</font>**

> **1）声明了自增主键：报主键冲突错误**
>
> ```mysql
> 1）将主键类型修改为 bigint 类型,8 个字节（ 2 ^ 64 - 1位）。
> 2）一般情况下，数据量达到500万时就应该考虑分库分表。
> ```
>
> **2）未声明自增主键：新数据会覆盖旧数据**
>
> ```mysql 
> Innodb会自动创建一个不可见的、长度为6个字节的row_id(bigint unsigned类型);
> Innodb会维护了一个全局的dictsys.row_id,未定义主键的表都共享该row_id,插入一条数据，都会把row_id当成主键id,然后 +1。
> 
> 如果全局row_id一直涨，涨到 2 ^ 48 - 1时，这个时候再+1, row_id 的低48位都为0，在插入新一行数据时，拿到的row_id就为0，再插入时会覆盖之前的值。
> ```

### 5.2 InnoDB在RR级别可以解决幻读，为何还要Serializable隔离级别?

```mysql

```



------

# 二、HashMap底层原理

## 1.HashMap & ConcurrentHashMap

### **1.1 底层结构**

```java
"Map 相关参数"：
{
    //1.初始化容量：16
    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; 
    //2.最大容量：1073741824
    static final int MAXIMUM_CAPACITY = 1 << 30;
    //3.加载因子(扩容因子)：默认0.75
    static final float DEFAULT_LOAD_FACTOR = 0.75f;
    //4.当链表长度大于此值且容量大于 64 时，转换为红黑树结构
	static final int TREEIFY_THRESHOLD = 8;
    static final int MIN_TREEIFY_CAPACITY = 64;
    //5.转换链表的临界值，当元素小于此值时，会将红黑树结构转换成链表结构
    static final int UNTREEIFY_THRESHOLD = 6;
}
HashMap底层结构（JDK 1.7 & 1.8）
/**JDK 1.7版本：数组 + 链表**/
/**JDK 1.8版本：数组 + 链表 & 红黑树 **/
ConcurrentHashMap底层结构【JDK 1.7 & 1.8】
/**JDK 1.7 : 分段锁(Segment,继承于ReentrantLock【涉及AQS】) + HashEntry：查询遍历链表的效率太低*/
/**JKD 1.8 : CAS + Synchronized  & sizeCtl参数：用于表初始化和调整大小*/
```

### 1.2底层实现

#### 1.2.1 put()

```java 
1)调用putVal方法添加元素;
2)如果table为空/table的长度为0，进行resize()扩容;否则根据计算元素下标位置index=[hash & (n-1)]，该位置不存在元素时，调用newNode创建一个节点直接插入table中即可；
3)如果该位置存在节点，判断key是否相等【key & hash都相等】，更新节点的value;
    key不相等 & 首节点为TreeNode红黑树类型：调用putTreeVal方法增加树节点【每次插入节点时，将其与当前节点进行比较，待插入节点较小时，查找左子树，否则查找右子树，直到找到空位。此时，执行balanceInsert(插入节点并调整平衡) & moveRootToFront（调整后可能需要重置根节点）】;
    key 不相等 & 首节点为链表：遍历链表更新节点/插入节点【链表尾部插入】，插入之后判断链表长度是否大于建树阈值，决定是否需要将链表转换为红黑树。
4)存放元素后modCount+1,判断是否需要扩容。
```
![image-20210719172116629.png](..\pictures\image-20210719172116629.png)

#### 1.2.2 resize()

```java
思想：重写规划长度和阈值，如果长度发生了变化，部分数据节点也要重新排列
重新规划长度：
    1)如果当前容量oldCap > 0 & 达到最大值，将阈值设为Integer的最大值，return终止扩容；
    2)如果未达到最大容量，当oldCap << 1 不超过最大容量时,就扩大2倍；
    3)如果都不满足且当前扩容阈值 oldThr > 0,使用当前扩容阈值作为新容量；
    4)否则将新容量置为初始容量16,新扩容阈值置为12。
重写排列数据节点：
    1)如果节点为null：不进行处理;
    2)如果节点不为null & 没有next节点，通过[节点的hash & (新容量-1)]计算出节点在table数组中的下标;
    3)如果节点为TreeNode类型，调用split方法处理，如果节点数hc达到6，调用untreeify方法转回链表;
    4)如果是链表节点，需要将链表拆分为[hash值超出旧容量 & hash值未超出旧容量]的链表，对于hash & oldCap == 0 的部分不做处理，否则将节点放在新下标的位置。[新下标 = 旧下标 + 旧容量]
```

### 1.3 HashMap线程不安全

```Java
1.数据丢失【JDK 1.7 & 1.8均存在】:
	①并发赋值被覆盖：两个线程同时修改同一个key,后一个的修改会覆盖前一个的修改;
	②已遍历区间新增元素丢失：在transfer迁移过程中，其他线程在已遍历区间的哈希槽中新增数据，遍历完成后，table数组引用指向newTable,新增元素丢失;
	③新表被覆盖:resize完成后，table = newTable,后续元素会在newTable上插入。如果多个线程同时resize,因为newTable是线程私有的局部变量，后面线程的newTable可能会覆盖之前线程的newTable,导致前一个线程在newTable上插入的元素被覆盖。
2.死循环【JDK 1.7存在,1.8不存在该问题】
     resize() 扩容时调用transfer方法转移元素时使用头插法，由于原table共享，若多个线程对next指针进行并发修改，其中某个线程还没有将table = newTable时，时间片用完，多线程就会陷入死循环。
```

------

# 三、并发编程

## 1.Java 锁

### 1.1谈谈Java锁

```java
锁的出现：并发编程中，当多个线程对同一个共享变量进行读写操作时，会产生数据不一致的问题，可以通过锁来解决；
锁的分类：锁可以按照不同的标准分为以下几类
	1)可重入锁 & 不可重入锁:同一线程在外层方法中获得锁，进入内层方法时会自动获取锁;
	2)乐观锁 & 悲观锁 ： 线程在处理共享数据时先不加锁，更新数据时判断是否需要加锁;
	3)公平锁 & 非公平锁 ： 锁的获取顺序按照请求的绝对时间顺序（遵循FIFO原则），获取锁时会判断当前节点的是否有前驱节点，等待其释放锁后，才能获取锁;
	4)独占锁 & 共享锁：锁一次是否只能被一个线程持有，若是：为独占锁（synchronized & ReentrantLock），否则为共享锁;
	5)读写锁：维护一个读锁和写锁，通过分离读写操作来提高并发性，其实现依赖AQS(抽象队列同步器)，其读写状态就是同步器的同步状态【int变量的高16、低16位分别表示读和写线程状态】
        涉及锁降级问题：保持当前写锁，再次获取读锁，随后再释放先前拥有的写锁。
        不直接释放写锁，获取读锁原因：保证数据的可见性【如果先释放写锁，假设此时另一个线程A获得写锁并修改了数据，当前线程无法感知线程A的数据更新】
    6)自旋锁 & 适应性自旋锁
 		自旋锁：尝试获取锁的线程不会立即阻塞，会采用循环的方式重新尝试获取(默认自旋10次)；
         适应性自旋锁：自旋时间不固定，由前一次的自旋时间和锁的拥有者决定。如果在同一个锁上，通过自旋刚刚成功获取过锁且持有锁的线程正在运行，JVM会认为这次自旋很有可能成功，进而允许自旋持续更新，否则，直接放弃自旋，避免浪费资源。(经验值自旋)
    7)无锁 & 偏向锁 & 轻量级锁 & 重量级锁【锁的状态】
          无锁(01 & 是否为偏向锁 = 0):未对资源进行锁定，所有线程都能访问并修改同一资源【修改操作在循环内执行，线程会不断尝试修改共享资源】，但只有一个线程能够修改成功；
          偏向锁(01 & 是否为偏向锁 = 1):同一段代码同时被一个线程访问，该线程会自动获取锁，降低获取锁的代价【不存在多线程竞争问题,JDK 6之后默认启用】
          轻量级锁(00):当前锁为偏向锁 & 被另一个线程访问时，会升级为轻量级锁，另一个线程会通过自旋的方式尝试获取锁，不会阻塞，从而提高性能；
          重量级锁(10):若当前只有一个线程等待，则该线程通过自旋等待，当自旋超过一定次数 || 此时有另一线程请求锁时，轻量级锁升级为重量级锁。
```

- **非公平锁是怎么处理阻塞的，新进来的线程怎么做？**

### 1.2 ReentrantLock & Synchronized

#### 1.2.1 谈谈Synchronized

```java
1.修饰范围：
	1)实例方法：作用于当前对象实例加锁，进入同步代码前要获得当前实例对象的锁;
	2)静态方法：作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁;
	3)代码块：指定加锁对象，对给定对象加锁，进入同步代码块前要获得给定对象的锁。
2.底层原理:
	1)代码块： synchronized 同步代码块使用 monitorenter & monitorexit指令;
	2)方法： synchronized 同步方法使用 ACC_SYNCHRONIZED 标识，指明该方法是一个同步方法，JVM通过该标识辨别一个方法是否声明为同步方法，执行同步操作。
3.JDK 1.6的优化
	引入自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁和轻量级锁等技术来减少锁操作的开销。
```

#### 1.2.2谈谈ReentrantLock

```java 
1)底层通过AQS + CAS 实现，使用共享资源volatile State作为同步状态变量;
2)ReentrantLock通过调用AQS的getState、setState、CompareAndSetState三个方法来管理State同步状态，从而实现公平锁 & 非公平锁 lock & unlock;
3)实现Lock接口，并构造了三个内部类[继承自AQS的Sync类、继承自Sync的FairSync & NonfairSync,分别实现公平锁 & 非公平锁。
```

- **公平锁实现**

  ```Java
  1.获取状态state，若state == 0 ：代表锁没有被其他线程占用[同步队列中可能有线程等待]，执行2；否则，执行3;
  2.state == 0:判断同步队列是否存在线程(节点)，若不存在，直接将锁的所有者设置成当前线程，且更新state状态，返回true;否则,加入等待队列并返回false;
  3.判断锁的所有者是不是当前线程，若是，则更新state状态，返回true;否则，将当前线程加入同步队列等待并返回false。
  ```

  ![image-20210721095733954.png](..\pictures\image-20210721095733954.png)

- **非公平锁实现**

  ```java
  1.调用CAS设置state的值：若state == 0，将其设置为1，并执行 setExclusiveOwnerThread() 方法将当前线程设置为锁的所有者；若CAS设置失败，代表锁被占用，执行 acquire(1);
  2. acquire(1):重写 tryAcquire()，内部调用 boolean nonfairTryAcquire().
      nonfairTryAcquire() 内部执行流程：
      1)调用getState方法获取state的值：
      	若state == 0:将 state 设置为1，并执行 setExclusiveOwnerThread()方法将当前线程设置为锁的所有者；
      	若state != 0:调用 getExclusiveOwnerThread() 方法查看占用锁的线程是否为当前线程，若是，则将 state + 1 并返回 true;否则返回false,线程进入同步队列。 
  ```

  ![image-20210721095617360.png](..\pictures\image-20210721095617360.png)

#### 1.2.3 比较Synchronized & ReentrantLock

```java
1)两者都是可重入锁，自己可以再次获取自己的内部锁；
2)synchronized 依赖于JVM;ReentrantLock依赖于API(JDK),需要通过lock & unlock方法配合try/finally语句块完成。
3)ReentrantLock 比 synchronized增加了一些高级功能：
    等待可中断：通过lock.lockInterruptibly()来实现【正在等待的线程可以选择放弃等待】；
    可实现公平锁；而 synchronized 是非公平的【原因：所有收到锁请求的线程⾸先⾃旋，如果通过⾃旋也没有获取锁将被放⼊ ContentionList，该做法对于已
经进⼊队列的线程不公平。】
    可实现选择性通知（锁可以绑定多个条件）：线程对象可以注册到指定的Condition中，实现选择性的线程通知，在调度上更加灵活；
    性能不是区分 synchronized & ReentrantLock的标准：JDK 1.6之前 synchronized 的吞吐量会随着线程数的增加而急剧下降，JDK 1.6之后，性能基本持平。
```

## 2.JUC包

### 2.1CAS实现原理？什么情况下使用CAS？ABA问题及解决方案

```java
本质都是调用 compareAndSwapInt(obj,offset,expect,update):如果obj的 value 和 except相等，就将其更新为update,若CAS未成功，就自旋CAS。
ABA问题就是：线程读取时变量x的值为a,此时，另一个线程将变量x的值先变为b,又变回a,之后第一个线程对变量x进行CAS操作成功。
解决方案：atomic包中的AtomicStampedReference通过添加版本号解决该问题。
```

##  3.多线程

### 3.1三种实现方式

```Java
1）继承Thread类，并重写其run()方法   
public class testThread extends Thread{
    @Override
    public void run(){
        //具体实现
    }
}
"使用":new TestThread().start();
2）实现Runnable接口,并重写其run()方法
public class testThread implements Runnable{
    @Override
    public void run(){
        //具体实现
    }
}
"使用":作为Thread的参数使用，new Thread(new TestThread1()).start();
3）实现Callable接口，并重写其call()方法【有返回值】
class TestThread2 implements Callable{
    @Override
    public Object call() throws Exception {
        System.out.println("实现Callable接口......");
        return null;
    }
}
"使用"：new FutureTask<Object>(new TestThread2()).run();
```

### 3.2为什么使用多线程

```json
程序中有很多操作时非常耗时的【数据库的读写、IO操作等】，如果使用单线程，程序就必须等这些操作完成后才能执行其他操作。使用多线程可以将耗时任务放在后台继续执行，同时执行其他操作，提高系统的性能及CPU的利用率。
```

### 3.3什么时候使用多线程

```Java
/**注意:多线程可以更加充分地利用CPU的资源,不会增加CPU的处理性能*/
是否使用多线程很大程度上取决于应用程序的类型;
多线程的应用场景：
    1）IO密集型任务：IO操作比较耗时，当程序在等待资源的过程中，可以使用多线程来执行其他操作，提高系统性能；
    2）并行任务：C/S架构中，服务器端可以通过并行任务来处理用户的请求，提高响应速度；
    3）多CPU系统中，可以使用多线程提高CPU的利用率；
```

## 4.线程池

### 4.1核心参数

```java
七个：核心线程数、最大线程数、非核心线程的最大存活时间、空闲存活时间单位、工作队列、创建线程的工厂、饱和策略
```

### 4.2线程池类型

```Java
newCachedThreadPool:可缓存线程池【核心线程数为0，最大线程数为 Integer 的最大值，空闲存活时间为60s,无容量的同步队列】
newFixedThreadPool:固定工作线程数量线程池【核心与最大相等，无空闲存活时间，无界队列】
newScheduleThreadPool:定长定时周期线程池【最大线程数为 Integer 的最大值，无空闲存活时间，延迟队列】
newSingleThreadExecutor：单线程线程池【核心线程数 & 最大线程数 = 1，无空闲存活时间，无界队列】
newWorkStealingPool：创建持有足够线程的线程池支持给定的并行度，通过多个队列减少竞争【JDK 8 引入】
```

### 4.3饱和策略

```java
AbortPolicy:抛出异常(默认策略)
DiscardPolicy:抛弃新提交任务
DiscardOldestPolicy:抛弃队列中最老任务，将当前任务加入任务队列
CallerRunsPolicy:将任务交于线程池调用的线程处理
```

