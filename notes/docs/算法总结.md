## 1.回溯算法

**<font color = skyBlue>回溯算法模板框架（抽象为树来解决）</font>**

```Java
回溯三部曲：
    1) 确定递归函数参数;
    2) 确定终止条件;
    3) 确定单层搜索逻辑。
模板框架：
    void backtracking(参数) {
        if (终止条件) {
            存放结果;
            return;
        }

        for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
            处理节点;
            backtracking(路径，选择列表); // 递归
            回溯，撤销处理结果
        }
    }
```

### 1.1组合问题

**<font color=yellow>说明：将组合问题抽象为树结构时，问题转换为求符合要求的叶子节点。</font>**

#### 1.1.1 组合

**问题描述：给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。(n= 4,k=2)**

![image-20210719220903504](..\pictures\image-20210719220903504.png)

**代码实现：**

```java 
class Solution{
    List<List<Integer>> result = new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();
    public List<List<Integer>> combine(int n,int k){
        combineHelper(n,k,1);
        return result;
    }
    
    /**
    每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围，就是要靠startIndex
    @param startIndex用来记录本层递归中，集合从哪里开始遍历
    */
    private void combineHelper(int n,int k, int startIndex){
        //终止条件
        if(path.size() == k){
            result.add(new ArrayList<>(path));
            return ;
        }
        for(int i = startIndex; i <= n-(k - path.size())+1;i++){
            path.add(i);
            combineHelper(n,k,i+1);
            path.removeLast();    //回溯，撤销处理的节点
        }
    }
}
```

#### 1.1.2 组合总和I

**问题描述：给定一个无重复元素的正整数数组 candidates 和一个正整数 target ，找出 candidates 中所有可以使数字和为目标数 target 的唯一组合【candidates 可以重复使用】**

**代码实现**

```java
class Solution{
     List<List<Integer>> result = new ArrayList<>();
     LinkedList<Integer> path = new LinkedList<>();
     public List<List<Integer>> combinationSum(int[] candidates, int target) {
         backTracking(candidates,target,0,0);
         return result;
    }
    private void backTracking(int[] candidates,int target,int startIndex,int sum){
        //递归出口
        if(sum == target){
            result.add(new ArrayList<>(path));
            return ;
        }
        //递归式
        for(int i = startIndex; i < candidates.length;i++){
            if(sum + candidates[i] > target){
                break;
            }
            path.add(candidates[i]);
            sum += candidates[i];
            backTracking(candidates,target,i,sum);
            //回溯
            path.removeLast();
            sum -= candidates[i];
        }
    } 
}
```

#### 1.1.3 组合总和II

**问题描述：给定一个数组 candidates 和一个目标数 target，找出 candidates 中所有可以使数字和为 target 的组合。[<font color = yellow>candidates 中的每个数字在每个组合中只能使用一次!</font>]**

**<font color = red>难点：如何去重？</font>**

```java
去重理解：同一树层上“使用过”的元素，不能重复使用；同一树枝上的都是一个组合内的元素，可以重复。
具体做法：使用used[i]数组做标识,在candidates[i] == candidates[i-1]时：
    若used[i-1] == true:说明同一树枝使用过candidates[i-1],属于同一组合，可以重复使用；
    若used[i-1] == false:说明同一层次使用过candidated[i-1],属于不同组合，不能重复使用，继续执行下一次循环。
```

![image-20210720195440760](..\pictures\image-20210720195440760.png)

**代码实现**

```java
class Solution{
    List<List<Integer>> lists = new ArrayList<>();
    Deque<Integer> path = new LinkedList<>();
    int sum = 0;
    public List<List<Integer>> combinationSum2(int[] candidates,int target){
        //为将重复数字放在一起，先进行排序
        Arrays.sort(candidates);
        //构建标志数组，辅助判断同层次节点是否已经遍历
        boolean[] flag = new boolean[candidates.length];
        backTracking(candidates,target,0,flag);
        return lists;
    }
    private void backTracking(int[] arr,int target,int index,boolean[] flag){
        if(sum == target){
            lists.add(new ArrayList<>(path));
            return;
        }
        for(int i = index; i < arr.length && arr[i] + sum <= target;i++){
            //若出现重复节点 & 同层的第一个节点已经被访问过了，直接跳过
            if(i > 0 && arr[i] == arr[i-1] && !flag[i-1]){
                continue;
            }
            flag[i] = true;
            sum += arr[i];
            path.add(arr[i]);
            //每个节点只能访问一次，从下一个节点开始访问
            backTracking(arr,target,i+1,flag);
            //回溯
            int temp = path.pop();
            flag[i] = false;
            sum -= temp;
        }
    }
}
```

#### 1.1.4  组合总和III

**问题描述：找出所有相加之和为n的k个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。(n=4，k=2)**

![image-20210720153403037](..\pictures\image-20210720153403037.png)

**代码实现**

```java
class Solution {
    List<List<Integer>> result = new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();
    public List<List<Integer>> combinationSum3(int k, int n) {
        backTracking(n,k,1,0);
        return result;
    }

    private void backTracking(int n,int k,int startIndex,int sum){
        //剪枝
        if(sum > n){
            return;
        }

        if(path.size() == k){
            if(sum == n){
                result.add(new ArrayList<>(path));
            }
            return ;
        }
        //递归过程
        for(int i = startIndex; i <= 9-(k-path.size())+1;i++){
            path.add(i);
            sum += i;
            backTracking(n,k,i+1,sum);
            //回溯
            path.removeLast();
            sum -= i;
        }
    }
}
```

#### 1.1.5 电话号码的字母组合

**问题描述：给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。**

![image-20210726192821217](..\pictures\image-20210726192821217.png)

**代码实现**

```java 
class Solution {
    String[] letterMap = {" ","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
    List<String> res;
    StringBuilder temp = new StringBuilder();
    public List<String> letterCombinations(String digits) {
        res = new ArrayList<>();
        if(digits == null || digits.length() == 0){
            return res;
        }
        //dfs处理
        backTracking(digits,0);
        return res;
    }
    public void backTracking(String digits,int index){
        //递归出口
        if(index == digits.length()){
            res.add(temp.toString());
            return ;
        }

        //获取某数字对应的字符集
        String str = letterMap[digits.charAt(index)-'0'];
        for(int i = 0; i < str.length();i++){
            temp.append(str.charAt(i));
            backTracking(digits,index+1);
            //回溯操作
            temp.deleteCharAt(temp.length()-1);
        }
    }
}
```

### 1.2排列问题

### 1.3分割问题

**<font color=yellow>说明：将分割问题抽象为树结构时，问题转换为求符合要求的叶子节点。</font>**

#### 1.3.1 分割回文串

**问题描述：给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。返回 s 所有可能的分割方案。**

![image-20210726195824709](..\pictures\image-20210726195824709.png)

```java 
思路：
1.从头遍历分割点;
2.判断当前分割子串是否回文（双指针判断）;
3.回溯遍历并存储结果。
```

**代码实现**

```java 
class Solution {
    //存储结果
    List<List<String>> res = new ArrayList<>();
    //存储子串
    Deque<String> queue = new LinkedList<>();
    public List<List<String>> partition(String s) {
        backTracking(s,0);
        return res;
    }
    public void backTracking(String s,int startIndex){
        //递归出口
        if(startIndex == s.length()){
            res.add(new ArrayList<>(queue));
            return ;
        }
        //遍历逻辑
        for(int i = startIndex; i < s.length(); i++){
            if(isPalindrome(s,startIndex,i)){
                String str = s.substring(startIndex,i+1);
                queue.addLast(str);
            }else{
                continue;
            }
            //递归 + 回溯
            backTracking(s,i+1);
            queue.removeLast();
        }
    }
    
    //双指针判定回文
    private boolean isPalindrome(String s,int startIndex,int end){
        for(int i = startIndex,j = end; i < j ;i++,j--){
            if(s.charAt(i) != s.charAt(j)){
                return false;
            }
        }
        return true;
    }
}  
```

#### 1.3.2 复原IP地址

**问题描述：给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。**

**有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。**

![image-20210726211553868](..\pictures\image-20210726211553868.png)

**解题思路：**

```java 
从字符串首位开始判断[start,end]区间的子串所组成的数字是否合法,若合法则在其后添加"."并加入结果中;
判断子串是否合法：
    1）段位以0为开头的数字不合法
    2）段位里有非正整数字符不合法
    3）段位如果大于255了不合法
```

**代码实现**

```java
class Solution {
    List<String> res = new ArrayList<>();
    public List<String> restoreIpAddresses(String s) {
        if(s.length() > 12){
            return res;
        }
        backTracking(s,0,0);
        return res;
    }

    public void backTracking(String s,int startIndex,int pointNum){
        //递归终止条件
        if(pointNum == 3){
            if(isValid(s,startIndex,s.length()-1)){
                res.add(s);
            }
            return ;
        }
        
        //单层遍历逻辑
        for(int i = startIndex; i < s.length();i++){
            if(isValid(s,startIndex,i)){
                s = s.substring(0,i+1)+"."+s.substring(i+1);    //在符合条件的子串后添加"."
                pointNum++;
                backTracking(s,i+2,pointNum);
                //回溯
                pointNum--;
                s = s.substring(0,i+1)+s.substring(i+2);  	   //删除掉添加的"."
            }else{
                break;
            }
        }
    }

    //判断s在当前区间的子串是否合法
    private boolean  isValid(String s, int start,int end){
        if(start > end){
            return false;
        }

        //‘0’开头的数字不合法
        if(s.charAt(start)=='0' && start != end){
            return false;
        }
        //数字大于255不合法
        // int num = Integer.parseInt(s.substring(start,end+1));
        int num = 0;
        for(int i = start; i <= end;i++){
            num = num * 10 + (s.charAt(i)-'0');
            if(num > 255){
                return false;
            }
        }
        return true;
    }
}
```

### 1.4 子集问题

**<font color=yellow>说明：将"子集问题"抽象为树结构时，问题转换为求符合要求的所有节点（叶子 + 非叶子）。</font>**

#### 1.4.1 子集I

**问题描述：给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）（以nums=[1,2,3]为例求解）**

![image-20210726220518578](..\pictures\image-20210726220518578.png)

**思路分析：回溯三部曲**

```java
1.递归函数参数：一维数组path收集子集元素，二维数组res存放结果集;
2.终止条件：集合元素遍历完,startIndex > nums.length;
3.单层搜索逻辑：
    1)收集元素;
    2)递归;
    3)回溯到上一层
```

**代码实现**

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();
    public List<List<Integer>> subsets(int[] nums) {
        if(nums == null || nums.length == 0){
            res.add(new ArrayList<>());
            return res;
        }
        backTracking(nums,0);
        return res;
    }
    //DFS + 回溯
    public void backTracking(int[] nums,int startIndex){
        //遍历每个节点之前，把之前的节点记录下来
        res.add(new ArrayList<>(path));
        //终止条件
        for(int i = startIndex;i < nums.length;i++){
            path.add(nums[i]);
            backTracking(nums,i+1);
            path.removeLast();
        }
    }
}
```

#### 1.4.2 子集II

#### 1.4.3 递增子序列

### 1.5 棋盘问题



