## 1.回溯算法

**<font color = skyBlue>回溯算法模板框架（抽象为树来解决）</font>**

```Java
回溯三部曲：
    1) 确定递归函数参数;
    2) 确定终止条件;
    3) 确定单层搜索逻辑。
模板框架：
    void backtracking(参数) {
        if (终止条件) {
            存放结果;
            return;
        }

        for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
            处理节点;
            backtracking(路径，选择列表); // 递归
            回溯，撤销处理结果
        }
    }
```

### 1.1组合问题

**<font color=yellow>说明：将组合问题抽象为树结构时，问题转换为求符合要求的叶子节点。</font>**

#### 1.1.1 组合

**问题描述：给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。(n= 4,k=2)**

![image-20210719220903504](../pictures/image-20210719220903504.png)

**代码实现：**

```java 
class Solution{
    List<List<Integer>> result = new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();
    public List<List<Integer>> combine(int n,int k){
        combineHelper(n,k,1);
        return result;
    }
    
    /**
    每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围，就是要靠startIndex
    @param startIndex用来记录本层递归中，集合从哪里开始遍历
    */
    private void combineHelper(int n,int k, int startIndex){
        //终止条件
        if(path.size() == k){
            result.add(new ArrayList<>(path));
            return ;
        }
        for(int i = startIndex; i <= n-(k - path.size())+1;i++){
            path.add(i);
            combineHelper(n,k,i+1);
            path.removeLast();    //回溯，撤销处理的节点
        }
    }
}
```

#### 1.1.2 组合总和I

**问题描述：给定一个无重复元素的正整数数组 candidates 和一个正整数 target ，找出 candidates 中所有可以使数字和为目标数 target 的唯一组合【candidates 可以重复使用】**

**代码实现**

```java
class Solution{
     List<List<Integer>> result = new ArrayList<>();
     LinkedList<Integer> path = new LinkedList<>();
     public List<List<Integer>> combinationSum(int[] candidates, int target) {
         backTracking(candidates,target,0,0);
         return result;
    }
    private void backTracking(int[] candidates,int target,int startIndex,int sum){
        //递归出口
        if(sum == target){
            result.add(new ArrayList<>(path));
            return ;
        }
        //递归式
        for(int i = startIndex; i < candidates.length;i++){
            if(sum + candidates[i] > target){
                break;
            }
            path.add(candidates[i]);
            sum += candidates[i];
            backTracking(candidates,target,i,sum);
            //回溯
            path.removeLast();
            sum -= candidates[i];
        }
    } 
}
```

#### 1.1.3 组合总和II

**问题描述：给定一个数组 candidates 和一个目标数 target，找出 candidates 中所有可以使数字和为 target 的组合。[<font color = yellow>candidates 中的每个数字在每个组合中只能使用一次!</font>]**

**<font color = red>难点：如何去重？</font>**

```java
去重理解：同一树层上“使用过”的元素，不能重复使用；同一树枝上的都是一个组合内的元素，可以重复。
具体做法：使用used[i]数组做标识,在candidates[i] == candidates[i-1]时：
    若used[i-1] == true:说明同一树枝使用过candidates[i-1],属于同一组合，可以重复使用；
    若used[i-1] == false:说明同一层次使用过candidated[i-1],属于不同组合，不能重复使用，继续执行下一次循环。
```

![image-20210720195440760](../pictures/image-20210720195440760.png)

**代码实现**

```java
class Solution{
    List<List<Integer>> lists = new ArrayList<>();
    Deque<Integer> path = new LinkedList<>();
    int sum = 0;
    public List<List<Integer>> combinationSum2(int[] candidates,int target){
        //为将重复数字放在一起，先进行排序
        Arrays.sort(candidates);
        //构建标志数组，辅助判断同层次节点是否已经遍历
        boolean[] flag = new boolean[candidates.length];
        backTracking(candidates,target,0,flag);
        return lists;
    }
    private void backTracking(int[] arr,int target,int index,boolean[] flag){
        if(sum == target){
            lists.add(new ArrayList<>(path));
            return;
        }
        for(int i = index; i < arr.length && arr[i] + sum <= target;i++){
            //若出现重复节点 & 同层的第一个节点已经被访问过了，直接跳过
            if(i > 0 && arr[i] == arr[i-1] && !flag[i-1]){
                continue;
            }
            flag[i] = true;
            sum += arr[i];
            path.add(arr[i]);
            //每个节点只能访问一次，从下一个节点开始访问
            backTracking(arr,target,i+1,flag);
            //回溯
            int temp = path.pop();
            flag[i] = false;
            sum -= temp;
        }
    }
}
```

#### 1.1.4  组合总和III

**问题描述：找出所有相加之和为n的k个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。(n=4，k=2)**

![image-20210720153403037](../pictures/image-20210720153403037.png)

**代码实现**

```java
class Solution {
    List<List<Integer>> result = new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();
    public List<List<Integer>> combinationSum3(int k, int n) {
        backTracking(n,k,1,0);
        return result;
    }

    private void backTracking(int n,int k,int startIndex,int sum){
        //剪枝
        if(sum > n){
            return;
        }

        if(path.size() == k){
            if(sum == n){
                result.add(new ArrayList<>(path));
            }
            return ;
        }
        //递归过程
        for(int i = startIndex; i <= 9-(k-path.size())+1;i++){
            path.add(i);
            sum += i;
            backTracking(n,k,i+1,sum);
            //回溯
            path.removeLast();
            sum -= i;
        }
    }
}
```

#### 1.1.5 电话号码的字母组合

**问题描述：给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。**

![image-20210726192821217](../pictures/image-20210726192821217.png)

**代码实现**

```java 
class Solution {
    String[] letterMap = {" ","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
    List<String> res;
    StringBuilder temp = new StringBuilder();
    public List<String> letterCombinations(String digits) {
        res = new ArrayList<>();
        if(digits == null || digits.length() == 0){
            return res;
        }
        //dfs处理
        backTracking(digits,0);
        return res;
    }
    public void backTracking(String digits,int index){
        //递归出口
        if(index == digits.length()){
            res.add(temp.toString());
            return ;
        }

        //获取某数字对应的字符集
        String str = letterMap[digits.charAt(index)-'0'];
        for(int i = 0; i < str.length();i++){
            temp.append(str.charAt(i));
            backTracking(digits,index+1);
            //回溯操作
            temp.deleteCharAt(temp.length()-1);
        }
    }
}
```

### 1.2排列问题

#### 1.2.1 全排列

**<font color = skyblue>题目链接：https://leetcode-cn.com/problems/permutations/</font>**

**问题描述：给定一个 没有重复 数字的序列，返回其所有可能的全排列。**

![image-20210727192713413](../pictures/image-20210727192713413.png)

**代码实现**

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    Deque<Integer> path = new LinkedList<>();
    boolean[] used;
    public List<List<Integer>> permute(int[] nums) {
        Arrays.sort(nums);
        used = new boolean[nums.length];
        backTracking(nums);
        return res;
    }

    public void backTracking(int[] nums){
        //终止条件
        if(path.size() == nums.length){
            res.add(new ArrayList<>(path));
            return ;
        }

        //单层搜索逻辑
        for(int i = 0; i < nums.length;i++){
            //元素去重：
            if((i > 0 && nums[i] == nums[i-1] && !used[i-1]) ||used[i]){
                continue;
            }
            used[i] = true;
            path.addLast(nums[i]);
            backTracking(nums);
            path.removeLast();
            used[i] = false;
        }
    }
}
```

#### 1.2.2 全排列II

**问题描述：给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。**

![image-20210727192925237](../pictures/image-20210727192925237.png)

**解题思路: 同层去重 & DFS & 回溯 & 排序** 

```java
回溯三部曲：排列问题,不固定开始遍历位置，根据每层是否已经使用过相同元素（去重） & 该分支是否已经使用（使用过的元素不能重复使用）
	1.递归函数参数：数组nums & 全局的已使用元素标识数组used;
	2.终止条件:path.size() == nums.length;
	3.单层搜索逻辑：
        for(int i = 0; i < nums.size();i++){
            if( i > 0 && 同层重复 || 当前遍历元素已被使用){
                continue;
            }
            if(当前遍历元素未使用){
                //修改使用标识，加入path,继续dfs
                //回溯到上一层
            }
        }
```

**代码实现**

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    Deque<Integer> path = new LinkedList<>();
    boolean[] used;
    public List<List<Integer>> permute(int[] nums) {
        Arrays.sort(nums);
        used = new boolean[nums.length];
        backTracking(nums);
        return res;
    }

    public void backTracking(int[] nums){
        //终止条件
        if(path.size() == nums.length){
            res.add(new ArrayList<>(path));
            return ;
        }

        //单层搜索逻辑
        for(int i = 0; i < nums.length;i++){
            //元素去重：
            if((i > 0 && nums[i] == nums[i-1] && !used[i-1]) ||used[i]){
                continue;
            }
            used[i] = true;
            path.addLast(nums[i]);
            backTracking(nums);
            path.removeLast();
            used[i] = false;
        }
    }
}
```

### 1.3分割问题

**<font color=yellow>说明：将分割问题抽象为树结构时，问题转换为求符合要求的叶子节点。</font>**

#### 1.3.1 分割回文串

**问题描述：给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。返回 s 所有可能的分割方案。**

![image-20210726195824709](../pictures/image-20210726195824709.png)

```java 
思路：
1.从头遍历分割点;
2.判断当前分割子串是否回文（双指针判断）;
3.回溯遍历并存储结果。
```

**代码实现**

```java 
class Solution {
    //存储结果
    List<List<String>> res = new ArrayList<>();
    //存储子串
    Deque<String> queue = new LinkedList<>();
    public List<List<String>> partition(String s) {
        backTracking(s,0);
        return res;
    }
    public void backTracking(String s,int startIndex){
        //递归出口
        if(startIndex == s.length()){
            res.add(new ArrayList<>(queue));
            return ;
        }
        //遍历逻辑
        for(int i = startIndex; i < s.length(); i++){
            if(isPalindrome(s,startIndex,i)){
                String str = s.substring(startIndex,i+1);
                queue.addLast(str);
            }else{
                continue;
            }
            //递归 + 回溯
            backTracking(s,i+1);
            queue.removeLast();
        }
    }
    
    //双指针判定回文
    private boolean isPalindrome(String s,int startIndex,int end){
        for(int i = startIndex,j = end; i < j ;i++,j--){
            if(s.charAt(i) != s.charAt(j)){
                return false;
            }
        }
        return true;
    }
}  
```

#### 1.3.2 复原IP地址

**问题描述：给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。**

**有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。**

![image-20210726211553868](../pictures/image-20210726211553868.png)

**解题思路：**

```java 
从字符串首位开始判断[start,end]区间的子串所组成的数字是否合法,若合法则在其后添加"."并加入结果中;
判断子串是否合法：
    1）段位以0为开头的数字不合法
    2）段位里有非正整数字符不合法
    3）段位如果大于255了不合法
```

**代码实现**

```java
class Solution {
    List<String> res = new ArrayList<>();
    public List<String> restoreIpAddresses(String s) {
        if(s.length() > 12){
            return res;
        }
        backTracking(s,0,0);
        return res;
    }

    public void backTracking(String s,int startIndex,int pointNum){
        //递归终止条件
        if(pointNum == 3){
            if(isValid(s,startIndex,s.length()-1)){
                res.add(s);
            }
            return ;
        }
        
        //单层遍历逻辑
        for(int i = startIndex; i < s.length();i++){
            if(isValid(s,startIndex,i)){
                s = s.substring(0,i+1)+"."+s.substring(i+1);    //在符合条件的子串后添加"."
                pointNum++;
                backTracking(s,i+2,pointNum);
                //回溯
                pointNum--;
                s = s.substring(0,i+1)+s.substring(i+2);  	   //删除掉添加的"."
            }else{
                break;
            }
        }
    }

    //判断s在当前区间的子串是否合法
    private boolean  isValid(String s, int start,int end){
        if(start > end){
            return false;
        }

        //‘0’开头的数字不合法
        if(s.charAt(start)=='0' && start != end){
            return false;
        }
        //数字大于255不合法
        // int num = Integer.parseInt(s.substring(start,end+1));
        int num = 0;
        for(int i = start; i <= end;i++){
            num = num * 10 + (s.charAt(i)-'0');
            if(num > 255){
                return false;
            }
        }
        return true;
    }
}
```

### 1.4 子集问题

**<font color=yellow>说明：将"子集问题"抽象为树结构时，问题转换为求符合要求的所有节点（叶子 + 非叶子）。</font>**

#### 1.4.1 子集I

**问题描述：给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）（以nums=[1,2,3]为例求解）**

![image-20210726220518578](../pictures/image-20210726220518578.png)

**思路分析：回溯三部曲**

```java
1.递归函数参数：一维数组path收集子集元素，二维数组res存放结果集;
2.终止条件：集合元素遍历完,startIndex > nums.length;
3.单层搜索逻辑：
    1)收集元素;
    2)递归;
    3)回溯到上一层
```

**代码实现**

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();
    public List<List<Integer>> subsets(int[] nums) {
        if(nums == null || nums.length == 0){
            res.add(new ArrayList<>());
            return res;
        }
        backTracking(nums,0);
        return res;
    }
    //DFS + 回溯
    public void backTracking(int[] nums,int startIndex){
        //遍历每个节点之前，把之前的节点记录下来
        res.add(new ArrayList<>(path));
        //终止条件
        for(int i = startIndex;i < nums.length;i++){
            path.add(nums[i]);
            backTracking(nums,i+1);
            path.removeLast();
        }
    }
}
```

#### 1.4.2 子集II

**<font color = skyblue>题目链接：https://leetcode-cn.com/problems/subsets-ii/</font>**

**问题描述：给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。**

![image-20210727150815036](../pictures/image-20210727150815036.png)

**解题思路**

```java 
先排序，后去重【树层去重、树枝属于同一组合不去重】
    使用used[]标志数组,若nums[i] == nums[i-1]:
		1) 若 used[i-1] == true:属于同一树枝，不去重;
		2) 若 used[i-1] == false:属于同一树层，去重。
```

**代码实现**

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    Deque<Integer> path = new LinkedList<>();
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        Arrays.sort(nums);
        boolean[] used = new boolean[nums.length];
        backTracking(nums,0,used);
        return res;
    }
    public void backTracking(int[] nums,int startIndex,boolean[] used){
        res.add(new ArrayList<>(path));
        //终止条件
        if(startIndex >= nums.length){
            return ;
        }

        //单层搜索逻辑
        for(int i = startIndex; i < nums.length;i++){
            //同一层元素去重
            if(i > 0 && nums[i] == nums[i-1] && !used[i-1]){
                continue;
            }
            path.addLast(nums[i]);
            used[i] = true;
            //遍历下一层
            backTracking(nums,i+1,used);
            //回溯
            used[i] = false;
            path.removeLast();
        }
    }
}
```

#### 1.4.3 递增子序列

**<font color = skyblue>题目链接：https://leetcode-cn.com/problems/increasing-subsequences/</font>**

**问题描述：给定一个整型数组, 你的任务是找到所有该数组的递增子序列<font color=red>[子序列不一定连续]</font>，递增子序列的长度至少是2。**

![image-20210727154058380](../pictures/image-20210727154058380.png)

**解题思路：<font color = red>Set去重 + DFS + 回溯 </font>**

```Java
回溯三部曲：
    全局变量res存储结果,path存储符合条件的路径
	1.递归函数参数:数组nums,开始位置startIndex;
	2.终止条件：startIndex >= 2;[子序列长度至少为2]
	3.单层搜索逻辑：
        for(int i = startIndex; i < nums.length;i++){
            if(同一层重复 || 当前遍历元素 < path中最后一个元素){
            	继续遍历下一个元素
        	}
            //在set中添加本层已遍历元素，用于去重;
            //将元素添加到路径中
            //从下一个元素开始递归
            //回溯
        }
```

**代码实现**

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    Deque<Integer> path = new LinkedList<>();
    public List<List<Integer>> findSubsequences(int[] nums) {
        backTracking(nums,0);
        return res;
    }
    public void backTracking(int[] nums,int startIndex){
        //终止条件
        if(path.size() > 1){
            res.add(new ArrayList<>(path));
        }
        Set<Integer> useSet = new HashSet<>();
        //单层搜索逻辑
        for(int i = startIndex;i < nums.length;i++){
            //去重
            if((!path.isEmpty() && nums[i] < path.peekLast()) || useSet.contains(nums[i])){
                continue;
            }
            useSet.add(nums[i]);
            path.addLast(nums[i]);
            backTracking(nums,i+1);
            //回溯：set的作用范围在一层中，不会涉及下一层的操作，不用回溯
            path.removeLast();
        }         
    }
}
```

### 1.5 棋盘问题

#### 1.5.1 解数独

#### 1.5.2 N皇后问题

## 2. 贪心算法

**<font color = skyblue>贪心解题思路总结</font>**

****

```java
/**
本质：每一阶段选择局部最优解，从而达到全局最优
难点：如何通过局部最优解，推出整体最优解？
贪心算法解题步骤：
	1.将问题分解为若干个子问题；
	2.找出适合的贪心策略；
	3.求解每一个子问题的最优解；
	4.将局部最优解堆叠为全局最优解
*/
```

### 2.1 简单题目

#### 2.1.1  分发饼干

**<font color = skyblue>题目链接：https://leetcode-cn.com/problems/assign-cookies/</font>**

**问题描述：假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。**

**对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。**

**解题思路**

```java 
使用贪心策略，先将饼干数组 & 小孩数组排序：
   	将大饼干喂给胃口尽可能大的孩子，即从后向前遍历小孩数组，统计满足条件的数量。
```

![image-20210727202922469](../pictures/image-20210727202922469.png)

**代码实现**

```java 
class Solution {
    public int findContentChildren(int[] g, int[] s) {
        int res = 0;
        Arrays.sort(g);
        Arrays.sort(s);
        int index = s.length - 1;
        //对于从后向前遍历小孩的胃口大小，判断当前饼干大小是否满足胃口
        for(int i = g.length - 1; i >= 0; i--){
            //遍历饼干大小是否满足
            if(index >= 0 && g[i] <= s[index]){
                res++;
                index--;
            }
        }
        return res;
    }
}
```

#### 2.1.2 摆动序列

**<font color = skyblue>题目链接：https://leetcode-cn.com/problems/wiggle-subsequence/</font>**

**问题描述：给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序**

**<font color = red>说明：如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列</font>**

**解题思路：根据峰值变化判断是否为摆动序列**

![image-20210727210714541](../pictures/image-20210727210714541.png)

**代码实现**

```java 
class Solution {
    public int wiggleMaxLength(int[] nums) {
        //贪心策略：从前到后遍历数组，越过不符合条件的元素即可
        if(nums.length <= 1){
            return nums.length;
        }
        int res = 1;
        int curDiff = 0;
        int preDiff = 0;
        for(int i = 0; i < nums.length-1;i++){
            curDiff = nums[i+1] - nums[i];
            if((curDiff > 0 && preDiff <= 0) || (curDiff < 0 && preDiff >= 0)){
                res++;
                preDiff = curDiff;
            }
        }
        return res;
    }
}
```

#### 2.1.3 柠檬水找零

**<font color = skyblue>题目链接：https://leetcode-cn.com/problems/lemonade-change/</font>**

**问题描述**

```markdown
在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。
每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。
注意，一开始你手头没有任何零钱。

如果你能给每位顾客正确找零，返回 true ，否则返回 false 。
```

**解题思路**

```java 
记录三种面额的现有数量（five,ten,twen），并根据用户所给面额判断是否当前所拥有的面额是否够找零：
	1.bill == 5: five++即可;
	2.bill == 10: 判断five 是否大于 0 ,若是 five--,ten++;
	3.bill == 20: 判断ten > 0 且 five > 0 || five >= 3 || 返回false;
```

**代码实现**

```java
class Solution {
    public boolean lemonadeChange(int[] bills) {
        if(bills[0] != 5){
            return false;
        }
        int five = 0,ten = 0,twen = 0;
        for(int bill : bills){
            if(bill == 5){
                five++;
            }
            if(bill == 10){
                if(five <= 0){
                    return false;
                }
                five--;
                ten++;
            }
            if(bill == 20){
                if(ten > 0 && five > 0){
                    ten--;
                    five--;
                    twen++;
                }else if(five >= 3){
                    five -= 3;
                    twen++;
                }else{
                    return false;
                }
            }
        }
        return true;
    }
}
```

#### 2.1.4 K次取反后最大化的数组和

**<font color = skyblue>题目链接：https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/</font>**

**问题描述**

```java 
给定一个整数数组 A，我们只能用以下方法修改该数组：我们选择某个索引 i 并将 A[i] 替换为 -A[i]，然后总共重复这个过程 K 次。（我们可以多次选择同一个索引 i。）

以这种方式修改数组后，返回数组可能的最大和。
```

**解题思路**

```java
//难点：如何转变K次正负，让数组和达到最大？
1.先将原始数组排序;
2.从前向后遍历,将数组的前k个负数变为正数：
    若 k > 0 && nums[i] < 0：负数变为正数;
	若 k 已用完 || nums 全部是正数，退出循环;
3.对数组排序，并对数组的第一个元素反复进行正负转变;
4.求和即可。
```

**实现代码**

```java
class Solution {
    public int largestSumAfterKNegations(int[] nums, int k) {
        if(nums.length == 1){
            if( k%2== 0){
                return nums[0];
            }else{
                return -1 * nums[0];
            }
        }
        Arrays.sort(nums);
        //将nums按照绝对值从小到大排序
        for(int i = 0; i < nums.length;i++){
            if(k > 0 && nums[i] < 0){
                nums[i] = -1 * nums[i];
                k--;
            }else{
                break;
            }
        }
        Arrays.sort(nums);
        if(k!= 0 && k%2 != 0){
            nums[0] = -1 * nums[0];
        }
        return getSum(nums);
    }

    public int getSum(int[] nums){
        int sum = 0;
        for(int num : nums){
            sum += num;
        }
        return sum;
    }
}
```

#### 2.1.5 单调递增的数字

**<font color = skyblue>题目链接：https://leetcode-cn.com/problems/monotone-increasing-digits/</font>**

**问题描述**

```java
给定一个非负整数 N，找出小于或等于 N 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。
```

**解题思路**

```java 
将数字转换为字符串数组，从后向前遍历判断当前位与前一位的大小：
	若当前位小于前一位(即非递增),则将当前位-1,并按照贪心策略将该位置之后的所有字符串变为"9",最后通过 String.join("分隔符",拼接对象)转换为字符串.
```

**代码实现**

```java
class Solution {
    public int monotoneIncreasingDigits(int n) {
        String[] nStrs = String.valueOf(n).split("");
        int start =  nStrs.length;
        for(int i = nStrs.length -1; i > 0; i--){
            if(Integer.parseInt(nStrs[i-1]) > Integer.parseInt(nStrs[i])){
                nStrs[i-1] = String.valueOf(Integer.parseInt(nStrs[i-1]) - 1);
                start = i;
            }
        }

        //将start之后的位置全改为9
        for(int i = start; i < nStrs.length;i++){
            nStrs[i] = "9";
        }
        return Integer.parseInt(String.join("",nStrs));
    }
}
```

#### 2.1.6 最大子序和

**<font color = skyblue>题目链接：https://leetcode-cn.com/problems/maximum-subarray/</font>**

**问题描述**

```java
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
```

**解题思路**

```java
局部最优：当“连续和”为负数时立刻放弃，从下一个元素开始重新计算"连续和"。
全局最优：选取最大“连续和”
```

**代码实现**

```Java
class Solution {
    public int maxSubArray(int[] nums) {
        //2.贪心思路：舍弃连续和为负数的结果 & 选取“连续和”最大值作为结果
        int max = nums[0];
        int sum = nums[0];
        for(int i = 1;i < nums.length;i++){
            sum = nums[i]+Math.max(sum,0);
            max = Math.max(max,sum);
        }
        return max;
    }
}
```

### 2.2 中等难度

#### 2.2.1 股票问题

##### 1.买卖股票的最佳时机II

**<font color = skyblue>题目链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/</font>**

**问题描述**

```java
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
```

**解题思路：贪心策略（有利润时就出售，否则不出售）**

![image-20210806112759584](../pictures/image-20210806112759584.png)

**代码实现**

```java
class Solution {
    public int maxProfit(int[] prices) {
        int profit = 0;
        for(int i = prices.length-1;i > 0;i--){
            //贪心策略：若有盈利就出售，否则不出售
            profit += Math.max(prices[i]-prices[i-1],0);
        }
        return profit;
    }
}
```

##### 2.买卖股票的最佳时机含手续费

**<font color = skyblue>题目链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/</font>**

**问题描述**

```java
给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。
返回获得利润的最大值。
```

**解题思路**

```Java
//解法1：贪心策略
获利主要有三种情况：
    情况一：收获利润的这一天并不是收获利润区间里的最后一天（不是真正的卖出，相当于持有股票），所以后面要继续收获利润。
    情况二：前一天是收获利润区间里的最后一天（相当于真正的卖出了），今天要重新记录最小价格了。
    情况三：不作操作，保持原有状态（买入，卖出，不买不卖）
//解法2：动态规划
```

**代码实现**

```java 
class Solution {
    public int maxProfit(int[] prices, int fee) {
        //1.解法1：贪心策略
        int profit = 0;
        int minPrice = prices[0] + fee;
        for(int i = 1; i < prices.length;i++){
            //寻找最小买入点
            if(prices[i] + fee < minPrice){
                minPrice = prices[i] + fee;
            }else if(prices[i] > minPrice){
                profit += prices[i] - minPrice;
                minPrice = prices[i];   //卖出当前买入不需要再计算手续费用
            }
        }
       //解法2：动态规划
        return profit;
    }
}
```

****

#### 2.2.2 分发糖果

**<font color = skyblue>题目链接：https://leetcode-cn.com/problems/candy/</font>**

**问题描述**

```Java
老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。
你需要按照以下要求，帮助老师给这些孩子分发糖果：
    每个孩子至少分配到 1 个糖果。
    相邻的孩子中，评分高的孩子必须获得更多的糖果。
    那么这样下来，老师至少需要准备多少颗糖果呢？
```

**解题思路**

```java
两次贪心：
	先从左到右遍历：更新右边评分高的孩子糖果数（左边+1）;
	再从右到左遍历：更新左边评分高的孩子糖果数（右边+1,当前数量）
```

**代码实现**

```Java
class Solution {
    public int candy(int[] ratings) {
        int len  = ratings.length;
        int[] candies = new int[len];
        Arrays.fill(candies,1);
        //左贪心,更新右孩子
        for(int i = 1;i < len; i++){
            if(ratings[i] > ratings[i-1]){
                candies[i] = candies[i-1] + 1;
            }
        }

        //右贪心，更新左孩子
        for(int i = len-2;i >=0; i--){
            if(ratings[i] > ratings[i+1]){
                candies[i] = Math.max(candies[i],candies[i+1] + 1);
             }
        }
        //计算糖果数量
        int sum = 0; 
        for(int candy : candies){
            sum += candy;
        }
        return sum;
    }
}
```

#### 2.2.3 根据身高重建队列

**<font color = skyblue>题目链接：https://leetcode-cn.com/problems/queue-reconstruction-by-height/</font>**

**问题描述**

```Java
假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。

请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。
```

**解题思路**

```Java
对于多个维度的问题，通常先确定一个维度的顺序，再在此基础上，确定另一个维度的顺序。
	1.按照身高 hi 降序排序, 身高相同时，按照 ki 升序排序;
    2.以ki为下标,将数组people依次入队 
```

**代码实现**

```Java
class Solution {
    public int[][] reconstructQueue(int[][] people) {
        Arrays.sort(people,new Comparator<int[]>(){
            @Override
            public int compare(int[] p1,int[] p2){
                if(p1[0] == p2[0]){
                    //身高相同，人数升序
                    return p1[1] - p2[1];
                }else{
                    //身高降序排列
                    return p2[0] - p1[0];
                }
            }
        });
        LinkedList<int[]> que = new LinkedList<>();
        //以ki为下标存入队列
        for(int[] p : people){
            que.add(p[1],p);
        }
        //队列转为数组
        return que.toArray(new int[people.length][]);
    }
}
```

****

### 2.3 困难题目

#### 2.3.1 区间问题

##### 1.跳跃游戏

**<font color = skyblue>题目链接：https://leetcode-cn.com/problems/jump-game/</font>**

**问题描述**

```java
给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。
```

**解题思路**

![image-20210809224523328](../pictures/image-20210809224523328.png)

```Java
每次移动取最大跳跃步数（得到最大的覆盖范围），每移动一个单位，就更新最大覆盖范围 && （判断是否可以覆盖到最后一个元素 true || 不能覆盖到下一个元素 false)。
局部最优：每次取最大跳跃步数（取最大覆盖范围）;
全局最优：最后得到整体最大覆盖范围，看是否能到终点。
```

**代码实现**

```Java
class Solution {
    public boolean canJump(int[] nums) {
        int right = 0;
        if(nums == null || nums.length == 1){
            return true;
        }
        int end = nums.length-1;
        int i = 0;
        //贪心策略：每次更新当前位置可跳跃到的最大位置 & 判断是否可以到达下一个位置
        while(i < end){
            right = Math.max(right,i+nums[i]);
            if(right < i+1){
                return false;
            }else if(right >= end){
                return true;
            }
            i++;
        }
        return false;
    }
}
```

##### 2.跳跃游戏II

**<font color = skyblue>题目链接：https://leetcode-cn.com/problems/jump-game-ii/</font>**

**问题描述**

```java
给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。
你的目标是使用'最少的跳跃'次数到达数组的最后一个位置。
```

**解题思路**

```Java
局部最优：每步计算可覆盖的最大范围并判断是否可以覆盖终点，若不能覆盖，步数加1;
全局最优：一步尽可能多走，达到最小步数。
```

![image-20210810100533822](../pictures/image-20210810100533822.png)

**代码实现**

```Java
class Solution {
    public int jump(int[] nums) {
        if(nums == null || nums.length <= 1){
            return 0;
        }
        //可覆盖最大区域
        int maxDistance = 0;
        //跳跃次数
        int count = 0;
        //当前可覆盖最大区域
        int curDistance = 0;
        for(int i = 0; i < nums.length;i++){
            //更新可覆盖最大区域
            maxDistance = Math.max(maxDistance,i+nums[i]);
            //说明再跳一步就达到末尾
            if(maxDistance >= nums.length -1){
                count++;
                break;
            }
            //走到当前覆盖最大区域时，步数加1并更新可覆盖最大区域
            if(i == curDistance){
                curDistance = maxDistance;
                count++;
            }
        }
        return count;
    }
}
```

##### 3.用最少数量的箭引爆气球

**<font color = skyblue>题目链接：https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/</font>**

**问题描述**

```Java
在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。
一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。
给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。
```

**解题思路**

```Java
问题可以转换为求重叠区间的个数：寻找具有重叠区间的气球 & 寻找重叠气球最小右边界。
局部最优：当气球出现重叠时，一起射，所用弓箭最少;
全局最优：将区间内所有气球射爆所用的最少弓箭。
解题：
    1.按照开始位置对所有气球进行排序;
	2.判断两个气球是否有重叠(即第二个气球的开始位置是否大于前一个气球的结束位置);
	3.更新最小右边界
```

![image-20210810104714881](../pictures/image-20210810104714881.png)

**代码实现**

```java 
class Solution {
    public int findMinArrowShots(int[][] points) {
        if(points == null || points.length == 0){
            return 0;
        }
        //1.先对二维数组进行排序：使用Comparator比较器排序
        Arrays.sort(points,(o1,o2)->Integer.compare(o1[0],o2[0]));
        int count = 1;
        for(int i = 1; i < points.length;i++){
            //2.后一个开始 大于 前一个结束,说明不重叠
            if(points[i][0] > points[i-1][1]){
                count++;
            }else{
                //重叠时，更新最小右边界
                points[i][1] = Math.min(points[i-1][1],points[i][1]);
            }
        }
        return count;
    }
}
```

##### 4.无重叠区间

**<font color = skyblue>题目链接：https://leetcode-cn.com/problems/non-overlapping-intervals/</font>**

**问题描述**

```Java
给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。
注意: 可以认为区间的终点总是大于它的起点。 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。
```

**解题思路**

```java
问题思路转换:求非交叉区间的最大个数【结果 = 总区间个数 - 非交叉子区间的最大个数】
可以先对区间进行排序：
    若按照右边界排序：右边界越小，剩余的空间区间就越大，所以从左向右遍历，选右边界小的;
	若按照左边界排序：左边界越大，前面剩余空间区间就越大，所以从右向左遍历，选左边界大的
贪心策略：按照右边界排序
    局部最优：从左向右遍历，优先选取右边界小的区间;
	全局最优：选取最多的非交叉区间
```

**代码实现**

```java
class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {
        if (intervals.length < 2) return 0;
        //按照右边界升序排列
        Arrays.sort(intervals, new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {
               return o1[1] - o2[1];
            }
        });

        int count = 1;
        int edge = intervals[0][1];
        //求非交叉区间的最大个数
        for (int i = 1; i < intervals.length; i++) {
            if (intervals[i][0] >= edge) {
                count++;
                edge = intervals[i][1];
            }
        }
        return intervals.length - count ;
    }
}
```

##### 5.划分字母区间

**<font color = skyblue>题目链接：https://leetcode-cn.com/problems/partition-labels/</font>**

**问题描述**

```Java
字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。
```

**解题思路**

![image-20210817154505049](../pictures/image-20210817154505049.png)

```Java
在遍历的过程中相当于是要找每一个字母的边界，如果找到之前遍历过的所有字母的最远边界，说明这个边界就是分割点了。此时前面出现过所有字母，最远也就到这个边界了。可以分为如下两步：
    统计每一个字符最后出现的位置
    从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点。
```

**代码实现**

```java 
class Solution {
    public List<Integer> partitionLabels(String s) {
        //寻找每个字符可达到的最远位置
        Map<Character,Integer> map = new HashMap<>();
        char[] sChars = s.toCharArray();
        for(int i = 0; i < s.length();i++){
            map.put(sChars[i],i);
        }

        List<Integer> res = new ArrayList<>();
        int left = 0,right = 0;
        for(int i = 0; i < s.length();i++){
            right = Math.max(right,map.get(sChars[i]));
            //判断是否当前字符已经是该片段可以到达的最大位置
            if(i == right){
                res.add(right-left+1);
                left = right + 1;
            }
        }
        return res;
    }
}
```

##### 6.<font color = skyblue>合并区间</font>

**<font color = skyblue>题目链接：https://leetcode-cn.com/problems/merge-intervals/</font>**

**问题描述：给出一个区间的集合，请合并所有重叠的区间。**

**解题思路**

```Java
按照左边界从小到大排序，每次遍历记录start值
	局部最优：需要合并时，取两个区间的最大右边界作为新的右边界,并将 new int[]{start,largeEdge}加入结果集中;
		     无需合并时，将当前遍历的区间加入结果集
     全局最优：合并所有重叠区间
```

**代码实现**

```Java
class Solution {
    public int[][] merge(int[][] intervals) {
        if(intervals.length < 2){
            return intervals;
        }
        Arrays.sort(intervals,(a,b)->{
            return a[0]-b[0];
        });

        LinkedList<int[]> que = new LinkedList<>();
        int start = intervals[0][0];
        for(int i = 1 ;i < intervals.length;i++){
            if(intervals[i][0] > intervals[i-1][1]){
                //不合并区间,更新下一次区间开始值
                que.add(new int[]{start,intervals[i-1][1]});
                start = intervals[i][0];
            }else{
                //合并区间
                intervals[i][1] = Math.max(intervals[i-1][1],intervals[i][1]);
            }
        }
        que.add(new int[]{start,intervals[intervals.length-1][1]});
        return que.toArray(new int[que.size()][]);
    }
}
```

#### 2.3.2 加油站

#### 2.3.3 监控二叉树

## 3. 动态规划

**<font color = skyBlue>动态规划解题思路总结</font>**

```java 
1.确定dp数组（dp table）以及下标的含义
2.确定递推公式
3.dp数组如何初始化
4.确定遍历顺序
5.举例推导dp数组
```

### 3.1  背包问题

### 3.2 股票问题

#### 3.2.1 买卖股票的最佳时机（买卖一次）

**<font color = skyblue>题目链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/</font>**

**问题描述**

```java
给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。
你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。
返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。
```

**解题思路**

```java 
/**
        dp[i][0]: 第i天持有股票时的现金数量;
            分两种情况：
                第i-1天持有股票,i天继续持有(dp[i-1][0];)
                第i-1天未持有,i天买入(-price[i])
        dp[i][1]: 第i天不持有股票时的现金数量;
            分两种情况：
                第i-1天未持有股票,i天继续未持有; dp[i-1][1];
                第i-1天持有,i天卖出 price[i]+dp[i-1][0]
*/
```

**代码实现**

```java 
class Solution {
    public int maxProfit(int[] prices) {
        //动态规划解法
         int profit = 0;
         int[] dp = new int[prices.length];
         dp[0] = prices[0];
         for(int i = 1; i < prices.length;i++){
            profit = Math.max(profit,prices[i]-dp[i-1]);
            dp[i] = Math.min(dp[i-1],prices[i]);
         }
         return profit;
    }
}
```

#### 3.2.2 买卖股票的最佳时机II（买卖多次）

**<font color = skyblue>题目链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/</font>**

**问题描述**

```java
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
```

**解题思路**

```Java
由于可以多次买卖股票,第i天买入股票时,可能手中还有之前卖股票所获得的利润dp[i][0] = dp[i-1][1] - prices[i] 
```

**代码实现**

```java 
class Solution {
    public int maxProfit(int[] prices) {
        int[][] dp = new int[prices.length][2];
        //dp[i][0]表示持有股票时的现金，dp[i][1]表示不持有股票的现金
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for(int i = 1; i < prices.length;i++){
            dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1]-prices[i]);
            dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0]+prices[i]);
        }
        return dp[prices.length-1][1];
    }
}
```

#### 3.2.3 买卖股票的最佳时机III（最多买卖两次）

**<font color = skyblue>题目链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/</font>**

**问题描述**

```Java
给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
```

**解题思路**

```java
动态规划五部曲：
	1.确定dp数组的下标及意义：
		一天就有五个状态j： 无操作(0)、第一次买入(1)、第一次卖出(2)、第二次买入(3)、第二次卖出(4);
		定义 dp[i][j] 为：第i天经过状态j之后的最大现金.
    2.确定递推公式：
          dp[i][1]表示第i天保持在第一次买入的状态,可能有两种情况,取最大值即可:
				第i天买入:dp[i-1][0]-prices[i];
				第i天无操作,沿用前一天的状态：dp[i-1][1];
		 同理dp[i][2]表示第i天保持在第一次卖出的状态，可能有两种情况，取最大值即可:
				第i天卖出：dp[i-1][1] + prices[i];
				第i天无操作,沿用前一天的状态：dp[i-1][2];
		dp[i][3] = max(dp[i-1][2]-prices[i],dp[i-1][3]);
         dp[i][4] = max(dp[i-1][3]+prices[i],dp[i-1][4]);
	3.初始化：dp[0][0] = 0,dp[0][1] = -prices[0],dp[0][2] = 0(同一天买入 & 卖出),dp[0][3] = -prices[0],dp[0][4] = 0;
	4.遍历顺序：dp[i]依赖于dp[i-1],从前向后遍历;
	5.举例推导
```

![image-20210807140839959](../pictures/image-20210807140839959.png)

**代码实现**

```Java
class Solution {
    public int maxProfit(int[] prices) {
        //动态规划解决：确定五种状态
        int[][] dp = new int[prices.length][5];
        //初始化
        dp[0][0] = 0;
        dp[0][1] = -prices[0];
        dp[0][2] = 0;
        dp[0][3] = -prices[0];
        dp[0][4] = 0;
        for(int i = 1; i < prices.length;i++){
            dp[i][0] = dp[i-1][0];
            dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0]-prices[i]);
            dp[i][2] = Math.max(dp[i-1][2],dp[i-1][1]+prices[i]);
            dp[i][3] = Math.max(dp[i-1][3],dp[i-1][2]-prices[i]);
            dp[i][4] = Math.max(dp[i-1][4],dp[i-1][3]+prices[i]);
        }
        return dp[prices.length-1][4];
    }
}
```

#### 3.2.4 买卖股票的最佳时机IV（最多买卖K次）

**<font color = skyblue>题目链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/</font>**

**问题描述**

```java
给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
```

**解题思路**

```
***思路同上题***
```

**代码实现**

```java
class Solution {
    public int maxProfit(int k, int[] prices) {
        if(prices == null || prices.length == 0){
            return 0;
        }
        //dp[天数][股票状态]
        //股票状态：奇数表示第k次买入/持有,偶数表示第k次不持有/卖出
        int[][] dp = new int[prices.length][2*k+1];
        for(int i = 1; i <=2*k - 1;i = i + 2){
            dp[0][i] = -prices[0];
        }
        for(int i = 1; i < prices.length;i++){
            for(int j = 0; j < k*2 - 1;j=j+2){
                 dp[i][j+1] = Math.max(dp[i-1][j+1],dp[i-1][j]-prices[i]);
                 dp[i][j+2] = Math.max(dp[i-1][j+2],dp[i-1][j+1]+prices[i]);
            }
        }
        return dp[prices.length-1][2*k];
    }
}
```

#### 3.2.5 买卖股票的最佳时机含冷冻期(买卖多次，卖出有一天冷冻期)

**<font color = skyblue>题目链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/</font>**

**问题描述**

```Java
给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）
你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。卖出股票后，你无法在第二天买入股票 （即冷冻期为 1 天）。
```

**解题思路**

```
1.确定状态数组 & 含义：第i天共有j种状态：
	0：状态一（买入状态：当天买入/之前买入）
	1：状态二（卖出状态:两天前卖出（卖出当天+冷冻期一天），一直没操作）
	2: 状态三（卖出状态：当前卖出）
	3：状态四（处于冷冻状态，只存在于当天）
2.确定递推公式：
	状态一：dp[i][0]
		前一天就是买入状态：dp[i][0] = dp[i-1][0];
		当天买入：
			前一天是冷冻期：dp[i][3]-prices[i];
			前一天是保持卖出状态（卖出在冷冻，未被买入）：dp[i][1]-prices[i]
	dp[i][0] = max(dp[i-1][0],max(dp[i][3]-prices[i],dp[i][1]-prices[i]));
	状态二:dp[i][1]
		前一天是卖出状态：dp[i-1][1];
		前一天是冷冻状态：dp[i-1][3]
	状态三：dp[i][2]
		当前卖出:dp[i-1][0] + prices[i]
	状态四：dp[i][3]
		前一天卖出股票:dp[i-1][2]
```

**代码实现**

```Java
public int maxProfit(int[] prices) {
        if (prices == null || prices.length < 2) {
            return 0;
        }
        int[][] dp = new int[prices.length][2];

        // bad case
        dp[0][0] = 0;
        dp[0][1] = -prices[0];
        dp[1][0] = Math.max(dp[0][0], dp[0][1] + prices[1]);
        dp[1][1] = Math.max(dp[0][1], -prices[1]);

        for (int i = 2; i < prices.length; i++) {
            // dp公式
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 2][0] - prices[i]);
        }

        return dp[prices.length - 1][0];
    }
```

#### 3.2.6 买卖股票的最佳时机含手续费(买卖多次，每次有手续费)

**<font color = skyblue>题目链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/</font>**

**问题描述**

```Java
给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。返回获得利润的最大值。
```

**代码实现**

```Java
class Solution {
    public int maxProfit(int[] prices, int fee) {
        int len = prices.length;
        // 0 : 持股（买入）
        // 1 : 不持股（售出）
        // dp 定义第i天持股/不持股 所得最多现金
        int[][] dp = new int[len][2];
        // 买入的时候就支付手续费
        dp[0][0] = -prices[0] - fee;
        for (int i = 1; i < len; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i] - fee);
            dp[i][1] = Math.max(dp[i - 1][0] + prices[i], dp[i - 1][1]);
        }
        return Math.max(dp[len - 1][0], dp[len - 1][1]);

    }
}
```

### 3.3 子序列问题

### 3.4 基础问题

## 4. 二叉树

### 4.1 遍历方式

### 4.2 属性问题

### 4.3 公共祖先问题

### 4.4 二叉树操作

## 5. 栈与队列

### 5.1 栈实现队列

**<font color = skyblue>题目链接：https://leetcode-cn.com/problems/implement-queue-using-stacks/</font>**

**问题描述**

```Java
使用栈实现队列的下列操作：
    push(x) -- 将一个元素放入队列的尾部。
    pop() -- 从队列首部移除元素。
    peek() -- 返回队列首部的元素。
    empty() -- 返回队列是否为空。
```

**解题思路**

```java 
考察栈和队列的特性：（栈：先进后出，队列：先进先出）
考虑使用两个栈来实现，一个栈用于输入(先进后出 1,2,3,4,5)，一个栈用于输出（先进后出：5,4,3,2,1），相当于两次逆序，就是正序
```

**代码实现**

```java 
class MyQueue {
    private LinkedList<Integer> inputStack,outputStack;

    //初始化操作
    public MyQueue() {
        inputStack = new LinkedList<>();
        outputStack = new LinkedList<>();
    }
    
    public void push(int x) {
        inputStack.push(x);
    }
    
    public int pop() {
        if(outputStack.isEmpty()){
            while(!inputStack.isEmpty()){
                outputStack.push(inputStack.pop());
            }
        }
        return outputStack.pop();
    }
    
    public int peek() {
      int res = this.pop();
      outputStack.push(res); 
      return res;
    }
    
    public boolean empty() {
        return outputStack.isEmpty() && inputStack.isEmpty();
    }
}
```

### 5.2 队列实现栈

**<font color = skyblue>题目链接：https://leetcode-cn.com/problems/implement-stack-using-queues/</font>**

**问题描述**

```Java
请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。
```

**解题思路**

```java
一个队列做备份：暂存入队的元素,另一个队列实现栈;
先将入栈元素放入备份队列中,然后将栈队列的元素转移到备份队列,最后两者身份交换即可。
```

**代码实现**

```java
class MyStack {
    Queue<Integer> queue1,queue2;
    public MyStack() {
        //原始队列
        queue1 = new LinkedList<>();
        //备份队列
        queue2 = new LinkedList<>();
    }
    
    /** Push element x onto stack. */
    public void push(int x) {
        //先放入辅助队列做备份，然后再转移，辅助队列在push之前始终保持空
        queue2.offer(x);
        while(!queue1.isEmpty()){
            queue2.offer(queue1.remove());
        }
        Queue<Integer> temp = queue2;
        queue2 = queue1;
        queue1 = temp;
    }

    public int pop() {
        return queue1.remove();
    }

    public int top() {
        return queue1.peek();
    }
    
    public boolean empty() {
        return queue1.isEmpty();
    }
}
```

### 5.3 有效的括号

**<font color = skyblue>题目链接：https://leetcode-cn.com/problems/valid-parentheses/</font>**

**问题描述**

```java
给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。
	有效字符串需满足：
		左括号必须用相同类型的右括号闭合。
		左括号必须以正确的顺序闭合。
```

**解题思路（栈 + 哈希表）**

**代码实现**

```java
class Solution {
    public boolean isValid(String s) {
        Map<Character,Character> map = new HashMap<>();
        map.put('(',')');
        map.put('[',']');
        map.put('{','}');
        Stack<Character> stack = new Stack<>();
        char[] chars = s.toCharArray();
        for(char c : chars){
            if(map.containsKey(c)){
                stack.push(c);
            }else if(!stack.isEmpty() &&map.get(stack.peek()) == c){
                stack.pop();
            }else{
                return false;
            }
        }
        return stack.isEmpty();
    }
}
```

### 5.4 删除字符串中所有相邻重复项

**<font color = skyblue>题目链接：https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/</font>**

**问题描述**

```Java
给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。在 S 上反复执行重复项删除操作，直到无法继续删除。
在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。
```

**解题思路**

```Java
判断当前栈定元素 是否与 入栈元素相同：
	若相同：删除栈顶元素；
	不相同：入栈
最后根据栈中元素，构架结果字符串即可
```

**代码实现**

```Java
class Solution {
    public String removeDuplicates(String s) {
        LinkedList<Character> stack = new LinkedList<>();
        char[] sChars = s.toCharArray();
        for(char c : sChars){
            if(stack.isEmpty() || stack.peek() != c){
                stack.push(c);
            }else{
                stack.pop();
            }
        }
        StringBuffer res = new StringBuffer();
        while(!stack.isEmpty()){
            res.append(stack.removeLast());
        }
        return res.toString();
    }
}
```

### 5.5 逆波兰表达式求值

**<font color = skyblue>题目链接：https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/</font>**

**问题描述**

```java
根据 逆波兰表示法，求表达式的值
	有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。
说明：	
    整数除法只保留整数部分。
    给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。
```

**代码实现**

```java
class Solution {
    public int evalRPN(String[] tokens) {
        Stack<String> stack = new Stack<>();
        for(String str : tokens){
            switch(str){
                case "+":
                    int second = Integer.parseInt(stack.pop());
                    int first = Integer.parseInt(stack.pop());
                    stack.push(String.valueOf(first + second));
                    break;
                case "-":
                    int s1 = Integer.parseInt(stack.pop());
                    int f1 = Integer.parseInt(stack.pop());
                    stack.push(String.valueOf(f1 - s1));
                    break;
                case "*":
                    int s2 = Integer.parseInt(stack.pop());
                    int f2 = Integer.parseInt(stack.pop());
                    stack.push(String.valueOf(f2 * s2));
                    break;
                case "/":
                    int s3 = Integer.parseInt(stack.pop());
                    int f3 = Integer.parseInt(stack.pop());
                    stack.push(String.valueOf(f3 / s3));
                    break;
                default:
                    stack.push(str);
                    break;
            }
        }
        return Integer.valueOf(stack.pop());
    }
}
```

### 5.6  滑动窗口的最大值(<font color = red>困难</font>)

**<font color = skyblue>题目链接：https://leetcode-cn.com/problems/sliding-window-maximum/</font>**

**问题描述**

```java
给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。
返回滑动窗口中的最大值。（能否在线性时间内解决此问题？）
```

**解题思路**

```java 
单调递减队列（双端队列） + 遍历
    //1.弹出元素：当前窗口的移除值等于队列出口的值时，弹出队首元素
    //2.放入元素：如果添加的元素大于入口处的元素，弹出入口元素，保证队列元素单调递减   
```

**代码实现**

```java
/**自定义单调递减队列 */
class MyQueue{
    Deque<Integer> deque = new LinkedList<>();
    //1.弹出元素：当前窗口的移除值等于队列出口的值时，弹出队首元素
    void poll(int val){
        if(!deque.isEmpty() && val == deque.peek()){
            deque.removeFirst();
        }
    }
    //2.放入元素：如果添加的元素大于入口处的元素，弹出入口元素，保证队列元素单调递减
    void add(int val){
        while(!deque.isEmpty() && val > deque.getLast()){
            deque.removeLast();
        }
        deque.add(val);
    }
    int peek(){
        return deque.peek();
    }
}
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        if(nums.length == 1){
            return nums;
        }
        int len = nums.length - k + 1;
        int[] res = new int[len];
        int num = 0;
        MyQueue queue = new MyQueue();
        for(int i = 0; i < k;i++){
            queue.add(nums[i]);
        }

        res[num++] = queue.peek();
        //滑动窗口移动
        for(int i = k; i < nums.length;i++){
            //对移除窗口的元素做操作
            queue.poll(nums[i-k]);
            //对新添加的元素操作
            queue.add(nums[i]);
            //将单调队列的队首元素添加到结果集中
            res[num++] = queue.peek();
        }
        return res;
    }
}
```

### 5.7 前K个高频元素

**<font color = skyblue>题目链接：https://leetcode-cn.com/problems/top-k-frequent-elements/</font>**

**问题描述**

```java
给定一个非空的整数数组，返回其中出现频率前 k 高的元素。
```

**解题思路（Map + 优先队列 + Entry排序）**

```java
1.根据给定数组，利用Map统计每个元素出现的频率;
2.定义升序优先队列，根据value对map中的元素进行排序;
3.根据排序后的entrySet，向优先队列中添加entry(队列长度大于k时，弹出首元素（频率最小）);
3.构造结果集：根据优先队列,开始构造结果集。
```

**代码实现**

```Java

class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int num : nums){
            map.put(num,map.getOrDefault(num,0)+1);
        }
        int[] res  = new int[k]; 
        //使用优先队列解决问题
        Set<Map.Entry<Integer,Integer>> entries = map.entrySet();
        PriorityQueue<Map.Entry<Integer,Integer>> queue = new PriorityQueue<>(((o1, o2) -> {
            //对Map的entry按照value升序排序
            return o1.getValue() - o2.getValue();
        }));

        for(Map.Entry<Integer,Integer> entry : entries){
            queue.add(entry);
            if(queue.size() > k){
                //弹出频率小的
                queue.remove();
            }
        }

        //构造结果集
        for(int i = k-1;i >=0 ;i--){
            res[i] = queue.remove().getKey();
        }

        return res;
    }
}
```



## 6. 链表

### 6.1 移除链表元素

**<font color = skyblue>题目链接：https://leetcode-cn.com/problems/remove-linked-list-elements/</font>**

**问题描述：删除链表中等于给定值 val 的所有节点。**

**解题思路：设置虚拟头节点，完成删除操作**

**代码实现**

```java
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        //设置虚拟头节点
        ListNode sentail = new ListNode(0);
        sentail.next = head;
        //设置前驱节点 & 当前节点
        ListNode cur = head,pre = sentail;
        while(cur != null){
            if(cur.val == val){
                //删除cur
                pre.next = cur.next;
            }else{
                //后移前驱节点
                pre = cur;
            }
            cur = cur.next;
        }
        return sentail.next;
    }
}
```

### 6.2 翻转链表

**<font color = skyblue>题目链接：https://leetcode-cn.com/problems/reverse-linked-list/</font>**

**问题描述：翻转一个单链表**

**解题思路：头插法 & 递归**

**代码实现**

```java
class Solution {
    //头插法实现
    public void reverseLinkedList(ListNode head)
    {
        ListNode pre = null;
        ListNode cur = head;
        while(cur != null){
            ListNode nextNode = cur.next; 
            cur.next = pre;
            pre = cur;
            cur = nextNode;
        }
    }

    public ListNode reverseList(ListNode head) {
        //头插法 & 递归
        return reverse(null,head);
    
    }
    public ListNode reverse(ListNode pre,ListNode cur){
        //递归法
        if(cur == null){
            return pre;
        }
        ListNode temp  = null;
        temp = cur.next;         //保存下一个开始节点
        cur.next = pre;     //翻转
        //更新指针
        pre = cur;
        cur = temp;
        return reverse(pre,cur);
    }
}
```

### 6.3 两两交换链表中的节点

**<font color = skyblue>题目链接：https://leetcode-cn.com/problems/swap-nodes-in-pairs/</font>**

**问题描述**

```java 
给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
```

**解题思路：模拟交换**

![image-20210802145344070](../pictures/image-20210802145344070.png)

**代码实现**

```java 
class Solution {
    public ListNode swapPairs(ListNode head) {
        //构造虚节点
        ListNode sential = new ListNode(0);
        sential.next = head;
        ListNode pre = sential;
        while(pre.next != null && pre.next.next != null){
            //记录下一个head节点
            ListNode temp = head.next.next;
            pre.next = head.next;
            head.next.next = head;
            head.next = temp;
            pre = head;
            head = head.next;
        }
        return sential.next;
    }
}
```

### 6.4 删除链表中的倒数第n个节点

**<font color = skyblue>题目链接：https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/</font>**

**问题描述：给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。**

![image-20210728094911206](../pictures/image-20210728094911206.png)

**解题思路：<font color = yellow>快慢指针</font>**

```java
设置快指针fast:先移动n个节点;
设置慢指针slow:当fast移动到第n个节点时，开始移动;
两者同时移动，直到fast到达末尾,删除slow当前节点即可。
```

**代码实现**

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode sential = new ListNode(-1);
        sential.next = head;
        ListNode fast = sential,slow = sential;

        while(n-- >=0){
             fast = fast.next;
        }
        //slow 指向要删除节点的前一个节点
        while(fast != null){
            slow = slow.next;
            fast = fast.next;
        }
        //删除倒数第n个节点
        slow.next = slow.next.next;
        return sential.next;
    }
}
```

### 6.5 链表相交

**<font color = skyblue>题目链接：https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/submissions/</font>**

**问题描述**

```java
给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。
```

![image-20210729145244388](../pictures/image-20210729145244388.png)

**代码实现**

```java
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        //1.双指针法解决：两个指针同时遍历 & 判断两个链表的对应节点是否相同
        ListNode fast = headA,slow = headB;
        while(fast != slow){
            fast =  fast == null? headB : fast.next;
            slow =  slow == null? headA : slow.next;
        }
        return fast;
    }
}
```

### 6.6 环形链表

**<font color = skyblue>题目链接：https://leetcode-cn.com/problems/linked-list-cycle-ii/</font>**

**问题描述**

```java 
给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。
为了表示给定链表中的环，使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。
说明：不允许修改给定的链表。
```

**解题思路**

![image-20210801190929338](../pictures/image-20210801190929338.png)

```java
快慢指针：
    1.快指针以慢指针二倍的速度遍历链表，找到两者相遇节点;
	2.快/慢指针从开始位置遍历,另一个指针从当前相遇位置,逐个遍历,直到再次相遇（环的入口）
```

**代码实现**

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        //解法：快慢指针实现
        ListNode fast = head,slow = head;
        while(fast != null && fast.next != null){
            slow = slow.next;
            fast = fast.next.next;
            if(fast == slow){
                fast = head;
                while(fast != slow){
                    fast = fast.next;
                    slow = slow.next;
                }
                return fast;
            }
        }
        return null;
    }
}
```

## 7. 数组 & 字符串

### 7.1 二分法

####  7.1.1二分查找

**<font color = skyblue>题目链接：https://leetcode-cn.com/problems/binary-search/</font>**

**问题描述**

```java 
给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。
```

**解题思路：分治思想**

```java 
mid = left + right / 2;
若 nums[mid] < target:在右半区间查找;
若 nums[mid] > target:在左半区间查找;
若 nums[mid] == target,返回mid;
未找到,返回-1
```

**代码实现**

```java
class Solution {
    public int search(int[] nums, int target) {
        //边界处理
        if(target < nums[0] || target >nums[nums.length-1]){
            return -1;
        }
        int left = 0,right = nums.length-1;
         while(left <= right){
            int mid = left + ((right - left) >> 1);
            if(nums[mid] == target){
                return mid;
            }else if(target < nums[mid]){
                right = mid - 1;
            }else if(target > nums[mid]){
                left = mid + 1;
            }
        }
        return -1;
    }
}
```

#### 7.1.2 搜索插入位置

**<font color = skyblue>题目链接：https://leetcode-cn.com/problems/search-insert-position/</font>**

**问题描述**

```java 
给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
你可以假设数组中无重复元素。
```

**解题思路（二分法）**

```java 
插入位置可能有以下四种情况:
	1）目标值在数组所有元素之前
	2）目标值等于数组中某一个元素
	3）目标值插入数组中的位置
	4）目标值在数组所有元素之后
 //注意二分区间
 若[left,right]:则right = mid-1;
 若[left,right):则right = mid;
```

![image-20210802184611832](../pictures/image-20210802184611832.png)

**实现代码**

```java 
class Solution {
    public int searchInsert(int[] nums, int target) {
        int n = nums.length;
        int low = 0,high = n-1;
        if(target < nums[low]){
            return 0;
        }
        if(target > nums[high]){
            return n;
        }
        while(low <= high){
            int mid = low + ((high-low)>>1);     //防止溢出
            if(nums[mid] > target){
                high = mid - 1;
            }else if(nums[mid] < target){
                low = mid + 1;
            }else{
                return mid;
            }
        }
        return high + 1;
    }
}
```

#### 7.1.3 在排序数组中查找元素的第一个和最后一个位置

**<font color = skyblue>题目链接：https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/</font>**

**问题描述**

```Java
给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 target，返回 [-1, -1]。
进阶：你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？
```

**解题思路**

```java
分以下几种情况：
    情况一：target 在数组范围的右边或者左边，例如数组{3, 4, 5}，target为2或者数组{3, 4, 5},target为6，此时应该返回{-1, -1}
    情况二：target 在数组范围中，且数组中不存在target，例如数组{3,6,7},target为5，此时应该返回{-1, -1}
    情况三：target 在数组范围中，且数组中存在target，例如数组{3,6,7},target为6，此时应该返回{1, 1}
```

**代码实现**

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int index = binarySearch(nums,target);
        //nums中不存在该值
        if(index == -1){
            return new int[]{-1,-1};
        }
        //滑动指针解决
        int left = index,right = index;
        //向左滑动，寻找左边界
        while(left - 1 >= 0 && nums[left - 1] == nums[index]){
            left--;
        }
        //向右滑动，寻找右边界
        while(right + 1 < nums.length && nums[right + 1] == nums[index]){
            right++;
        }
        return new int[]{left,right};
    }
    //二分查找
    private int binarySearch(int[] nums,int target){
        int left = 0,right = nums.length - 1;
        while(left <= right){
            int mid = left + (right - left)/2;
            if(nums[mid] == target){
                return mid;
            }else if(nums[mid] < target){
                left = mid + 1;
            }else{
                right = mid - 1;
            }
        }
        return -1;
    }
}
```

### 7.2  双指针法

#### 7.2.1 长度最小的子数组

**<font color = skyblue>题目链接： https://leetcode-cn.com/problems/minimum-size-subarray-sum/</font>**

**问题描述**

```java
给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。
```

**解题思路**

![image-20210804110248093](../pictures/image-20210804110248093.png)

```java
通过双指针来确定区间，并根据条件移动 起始指针 & 末尾指针来确定符合条件的子区间。 [滑动窗口]
滑动窗口需要确定三个问题:假设当前窗口和为sum
	1.窗口内是什么？    //sum >= target && 长度最小 的连续子数组
	2.如何移动窗口的起始位置？    //sum > targets时，缩小窗口区间
	3.如何移动窗口的结束位置？    
```

**代码实现**

```java 
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        //滑动窗口
        int slow = 0;
        int res = Integer.MAX_VALUE;
        int sum = 0;
        for(int fast = 0; fast < nums.length;fast++){
            sum += nums[fast];
            while(sum >= target){
                res = Math.min(res, fast-slow+1);
                sum -= nums[slow];
                slow++;
            }
        }
        return res == Integer.MAX_VALUE ? 0 : res;
    }
}
```

#### 7.2.2 移除元素

**<font color = skyblue>题目链接：https://leetcode-cn.com/problems/remove-element/</font>**

**问题描述**

```java
给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。
元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
```

**解题思路**

```Java
快慢指针：用快指针的元素覆盖慢指针的元素【慢指针指向指为指定val的位置】,覆盖之后两个指针同时后移,直到快指针到达末尾。
```

<video src="../pictures/移除元素.mp4"></video>

**代码实现**

```Java
class Solution {
    public int removeElement(int[] nums, int val) {
        //快慢指针
        int fastIndex = 0,slowIndex = 0;
        while(fastIndex < nums.length){
            //快指针元素为val时,只移动快指针；否则两个指针同时移动。
            if(nums[fastIndex] != val){
                nums[slowIndex] = nums[fastIndex];
                slowIndex++;
            }
            fastIndex++;
        }
        return slowIndex;
    }
}
```

#### 7.2.3 有序数组的平方

**<font color = skyblue>题目链接：https://leetcode-cn.com/problems/squares-of-a-sorted-array/</font>**

**问题描述**

```java
给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。
```

**解题思路**

```Java
开辟与原数组空间大小相等的数组空间 res
定义双指针(一个从头，一个从尾),双向遍历原始数组,并比较遍历元素平方值的大小从尾部开始存入 res,直到两个指针相遇。
只需要遍历一遍：时间复杂度 O(n),需要开辟新数组空间:空间复杂度为 O(n);
```

**代码实现**

```java
class Solution {
    public int[] sortedSquares(int[] nums) {
        int[] res = new int[nums.length];
        int left = 0,right = nums.length-1;
        int index = right;
        while(left <= right){
            if(nums[left] * nums[left] > nums[right] * nums[right]){
                res[index--] = nums[left] * nums[left];
                left++;
            }else{
                res[index--] = nums[right] * nums[right];
                right--;
            }
        }
        return res;
    }
}
```

