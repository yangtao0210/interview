## 1.回溯算法

**<font color = skyBlue>回溯算法模板框架</font>**

```Java
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

### 1.1组合问题

#### 1.1.1组合

**问题描述：给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。(n= 4,k=2)**

![image-20210719220903504](C:\Users\18434\AppData\Roaming\Typora\typora-user-images\image-20210719220903504.png)

**代码实现：**

```java 
class Solution{
    List<List<Integer>> result = new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();
    public List<List<Integer>> combine(int n,int k){
        combineHelper(n,k,1);
        return result;
    }
    
    /**
    每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围，就是要靠startIndex
    @param startIndex用来记录本层递归中，集合从哪里开始遍历
    */
    private void combineHelper(int n,int k, int startIndex){
        //终止条件
        if(path.size() == k){
            result.add(new ArrayList<>(path));
            return ;
        }
        for(int i = startIndex; i <= n-(k - path.size())+1;i++){
            path.add(i);
            combineHelper(n,k,i+1);
            path.removeLast();    //回溯，撤销处理的节点
        }
    }
}
```

#### 1.1.2组合总和I

**问题描述：给定一个无重复元素的正整数数组 candidates 和一个正整数 target ，找出 candidates 中所有可以使数字和为目标数 target 的唯一组合【candidates 可以重复使用】**

**代码实现**

```java
class Solution{
     List<List<Integer>> result = new ArrayList<>();
     LinkedList<Integer> path = new LinkedList<>();
     public List<List<Integer>> combinationSum(int[] candidates, int target) {
         backTracking(candidates,target,0,0);
         return result;
    }
    private void backTracking(int[] candidates,int target,int startIndex,int sum){
        //递归出口
        if(sum == target){
            result.add(new ArrayList<>(path));
            return ;
        }
        //递归式
        for(int i = startIndex; i < candidates.length;i++){
            if(sum + candidates[i] > target){
                break;
            }
            path.add(candidates[i]);
            sum += candidates[i];
            backTracking(candidates,target,i,sum);
            //回溯
            path.removeLast();
            sum -= candidates[i];
        }
    } 
}
```

#### 1.1.3组合总和II

**问题描述：给定一个数组 candidates 和一个目标数 target，找出 candidates 中所有可以使数字和为 target 的组合。[<font color = yellow>candidates 中的每个数字在每个组合中只能使用一次!</font>]**

**<font color = red>难点：如何去重？</font>**

```java
去重理解：同一树层上“使用过”的元素，不能重复使用；同一树枝上的都是一个组合内的元素，可以重复。
具体做法：使用used[i]数组做标识,在candidates[i] == candidates[i-1]时：
    若used[i-1] == true:说明同一树枝使用过candidates[i-1],属于同一组合，可以重复使用；
    若used[i-1] == false:说明同一层次使用过candidated[i-1],属于不同组合，不能重复使用，继续执行下一次循环。
```

![image-20210720195440760](C:\Users\18434\AppData\Roaming\Typora\typora-user-images\image-20210720195440760.png)

**代码实现**

```java
class Solution{
    List<List<Integer>> lists = new ArrayList<>();
    Deque<Integer> path = new LinkedList<>();
    int sum = 0;
    public List<List<Integer>> combinationSum2(int[] candidates,int target){
        //为将重复数字放在一起，先进行排序
        Arrays.sort(candidates);
        //构建标志数组，辅助判断同层次节点是否已经遍历
        boolean[] flag = new boolean[candidates.length];
        backTracking(candidates,target,0,flag);
        return lists;
    }
    private void backTracking(int[] arr,int target,int index,boolean[] flag){
        if(sum == target){
            lists.add(new ArrayList<>(path));
            return;
        }
        for(int i = index; i < arr.length && arr[i] + sum <= target;i++){
            //若出现重复节点 & 同层的第一个节点已经被访问过了，直接跳过
            if(i > 0 && arr[i] == arr[i-1] && !flag[i-1]){
                continue;
            }
            flag[i] = true;
            sum += arr[i];
            path.add(arr[i]);
            //每个节点只能访问一次，从下一个节点开始访问
            backTracking(arr,target,i+1,flag);
            //回溯
            int temp = path.pop();
            flag[i] = false;
            sum -= temp;
        }
    }
}
```

#### 1.1.4 组合总和III

**问题描述：找出所有相加之和为n的k个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。(n=4，k=2)**

![image-20210720153403037](C:\Users\18434\AppData\Roaming\Typora\typora-user-images\image-20210720153403037.png)

**代码实现**

```java
class Solution {
    List<List<Integer>> result = new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();
    public List<List<Integer>> combinationSum3(int k, int n) {
        backTracking(n,k,1,0);
        return result;
    }

    private void backTracking(int n,int k,int startIndex,int sum){
        //剪枝
        if(sum > n){
            return;
        }

        if(path.size() == k){
            if(sum == n){
                result.add(new ArrayList<>(path));
            }
            return ;
        }
        //递归过程
        for(int i = startIndex; i <= 9-(k-path.size())+1;i++){
            path.add(i);
            sum += i;
            backTracking(n,k,i+1,sum);
            //回溯
            path.removeLast();
            sum -= i;
        }
    }
}
```

#### 1.1.5电话号码的字母组合

### 1.2排列问题

### 1.3分割问题

### 1.4子集问题

### 1.5棋盘问题



